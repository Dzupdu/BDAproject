---
title: "project"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readr)
library(rstan)
library("ggplot2")
library("bayesplot")
options(mc.cores = parallel::detectCores())
life_expectancy <- read_csv("life-expectancy.csv")
```

```{r}
# 1. eritällään kaikki maiden ja maanosien nimet erikseen, omille listoille
# Valtioille/maille
maa_maara<-1
maa<-c("Afghanistan")
# Maanosille, kerätään manuaalisesti listaan
maanosat <-c("Asia" ,"Northern America", "Africa", "Europe", "Australia", "Americas", "South Africa","Oceania", "Latin America and the Caribbean", "World")
maanosat_maara <- length(maanosat)
years <- 1950:2019


for (i in 2:nrow(life_expectancy)){
  if (life_expectancy$Entity[i]!=life_expectancy$Entity[i-1]){
    if (!is.element(life_expectancy$Entity[i], maanosat)){
      maa_maara<-maa_maara+1
      maa<-append(maa,life_expectancy$Entity[i])
    }
  }
}

# 2. kerätään valtioiden elinikäodotukset omaan listaan ja sama maanosille oma lista.
maat_arvot<-c()
maanosa_arvot<-c()
for (i in 1:length(life_expectancy$Entity)){
  if(life_expectancy$Year[i]>=1950){
    if (!is.element(life_expectancy$Entity[i], maanosat)){
      maat_arvot<-append(maat_arvot,life_expectancy$`Life expectancy (years)`[i])
    }
    else{
      maanosa_arvot<-append(maanosa_arvot,life_expectancy$`Life expectancy (years)`[i])
    }
  }
}

# 3. luodaan matsiisi jossa riveillä on valtioiden nimet/maanosan nimet 
# ja sarakkaissa on vuosien 1950-2019 elinikäodotus arvot.

# Valtioille/maille
matriisi_maat<-matrix(nrow = maa_maara, ncol = 2020-1950+1)
for (i in 1:maa_maara){
  for (j in 1:70){
    p<-i-1
    matriisi_maat[i,j+1]<-maat_arvot[j+p*70]
  }
  matriisi_maat[i][]<-maa[i]
}

# Maanosille 
matriisi_maanosat<-matrix(nrow = maanosat_maara, ncol = 2020-1950+1)
for (i in 1:maanosat_maara){
  for (j in 1:70){
    p<-i-1
    matriisi_maanosat[i,j+1]<-maanosa_arvot[j+p*70]
  }
  matriisi_maanosat[i][]<-maanosat[i]
}

# 4. lopuksi plotataan kaikki maat/maanosta sen elinikäodotuksen mukaan.
# Maille

#for (i in 1:nrow(matriisi_maat)){
#  ika<-c()
#  for (j in 2:71){
#    ika<-append(ika,matriisi_maat[i,j])
#  }
#  plot(years,ika,main=matriisi_maat[i][1],xlab="Year",ylab="Life expectancy (years)")
#}

# Maanosille

for (i in 1:nrow(matriisi_maanosat)){
  ika<-c()
  for (j in 2:71){
    ika<-append(ika,matriisi_maanosat[i,j])
  }
  plot(years,ika,main=matriisi_maanosat[i][1],xlab="Year",ylab="Life expectancy (years)")
}

countries_num <- matrix(as.numeric(matriisi_maat[,-1]),    # Convert to numeric matrix
                  ncol = ncol(matriisi_maat[,-1]))

continents_num <- matrix(as.numeric(matriisi_maanosat[,-1]),    # Convert to numeric matrix
                  ncol = ncol(matriisi_maanosat[,-1]))

# koko maailma erilleen maanosista HUOM, älä aja tätä solua uudelleen
world_num <- continents_num[nrow(continents_num),]
continents_num <- continents_num[-nrow(continents_num), ]
maanosat_maara <- maanosat_maara - 1

data_countries <- list(y = countries_num, N = length(years) , Nc = maa_maara, Npred = 30)
data_continents <- list(y = continents_num, N = length(years) , Nc = maanosat_maara, Npred = 30)
data_world <- list(y = world_num, N = length(years), Npred = 30)

# funktio dataframe vektoreiden indeksöintiin
df_extract <- function(df_name, field, i ,j =0){
  str <- paste(as.character(df_name), "$`", as.character(field), "[", as.character(i), sep = "")
  if(j == 0){
    str <- paste(str, "]`", sep = "")
  }else{
    str <- paste(str, ",", as.character(j), "]`", sep = "")
  }
  return(eval(parse(text=str)))
}

```






```{r}
code_linear = "data {
 int < lower =0 > N; // number of data points
 int < lower =0 > Nc; //number of countries/continents
 matrix [Nc,N] y; // observation life expectancies, Nc countries
 int< lower =0 > Npred ; // predict this many years forward
}

transformed data{
  vector[N] x1; // just use years 1,2,...N instead giving x as argument
  for ( i in 1: N){
    x1[i] = i;
  }
  
}

parameters {
  real alpha[Nc];
  real beta[Nc];
  real < lower =0 > sigma;
  real bmu0;
  real < lower =0 > bsigma0;
  real amu0;
  real < lower =0 > asigma0;
}

 
 model {
    bmu0 ~ normal(0,10); // yearly change/slope
    amu0 ~ normal(50,20); // we have observations at x = 1 so lets just use something close to that
    bsigma0 ~ inv_chi_square(0.01); // deviation around 10
    asigma0 ~ inv_chi_square(0.01); // deviation around 10
    sigma ~ inv_chi_square(0.01); // deviation around 10 years
   beta ~ normal(bmu0,bsigma0);
   alpha ~ normal(amu0,asigma0);
   
   for ( j in 1: Nc ){
      y[j, ] ~ normal (alpha[j] + beta[j]*x1 , sigma);
   }
 }
 
 generated quantities {
    matrix [Nc,Npred] ypred;
    vector [Nc*N] log_like;
    vector [Nc*N] y_rep;
    
    for ( j in 1: Nc ){
      for(i in (N+1):(N+Npred)){
        ypred[j,i - N] = normal_rng(alpha[j] + beta[j] * i , sigma);
      }
    }
    
    for ( j in 1: Nc ){
      for ( i in 1: N){
        log_like[(j-1)*N + i] = normal_lpdf(y[j, i] | (alpha[j] + beta[j] * i) , sigma);
        y_rep[(j-1)*N + i] = normal_rng(alpha[j] + beta[j] * i , sigma);
      }
    }
}
"

sm_linear <- rstan::stan_model(model_code = code_linear)
continents_linear_model <- rstan::sampling(sm_linear, data = data_continents, control = list(max_treedepth = 15)) # 
#tallenna sovitus tiedostoon
continents_linear_model@stanmodel@dso <- new("cxxdso") 
saveRDS(continents_linear_model, file = "continents_linear_model_wpriors.rds")
```

```{r}
continents_linear_model <- readRDS("continents_linear_model_wpriors.rds")
draws_linear <- as.data.frame(continents_linear_model)
#monitor(continents_linear_model)

for (i in 1:9){
  ika<- c()
  for (j in 2:71){
    ika<-append(ika,matriisi_maanosat[i,j])
  }
  #print(i)
  ika <- append(as.numeric(ika), mean(df_extract("draws_linear", "ypred", i, 10)))
  plot(append(years, 2030),ika,main=matriisi_maanosat[i][1],xlab="Year",ylab="Life expectancy (years)")
}
```


```{r}
code_cubic_single = "data {
 int < lower =0 > N; // number of data points
 vector[N ]  x ; // observation year
 vector[N ]  y; // observation life expectancies, Nc countries
 int xpred ; // prediction year
}

transformed data{
  vector[N ]  x1 = x - x[1] + 1; // data starts at 1 for easy indexing
  vector[N ]  x2 ;
  vector[N ]  x3 ; 
  int xpred1 = xpred - x[1];
  for ( j in 1: N){
    x2[j] = x1[j]*x1[j];
    x3[j] = x2[j]*x1[j];
  }
}


parameters {
  real A;
  real B;
  real C;
  real D;
  real < lower =0 > sigma;
}
//transformed parameters {
  //vector[N ] mu = A*x3 + B*x2 + C*x1 + D;
//}
 
 model {
      A ~ normal(0,0.1);
      B ~ normal(0,1);
      C ~ normal(0,10);
      D ~ normal(0,100);
      sigma ~inv_chi_square(0.01);
      
      y ~ normal (A*x3 + B*x2 + C*x1 + D , sigma);
   
 }
 
 generated quantities {
  real ypred = normal_rng(A*xpred1^3 + B*xpred1^2 + C*xpred1 + D , sigma );
}
"

sm_cubic_single <- rstan::stan_model(model_code = code_cubic_single)
world_cubic_model <- rstan::sampling(sm_cubic_single, data = data_world, iter = 10000, control = list(max_treedepth = 15))
world_cubic_model@stanmodel@dso <- new("cxxdso") 
saveRDS(world_cubic_model, file = "world_cubic_model.rds")
monitor(world_cubic_model)
```



```{r}
code_cubic = "data {
 int < lower =0 > N; // number of data points
 int < lower =0 > Nc; //number of countries/continents
 matrix [Nc,N] y; // observation life expectancies, Nc countries
 int< lower =0 > Npred ; // prediction year
}

transformed data{
  vector[N] x1;
  vector[N] x2;
  vector[N] x3;// just use years 1,2,...N instead giving x as argument
  for ( i in 1: N){
    x1[i] = i;
    x2[i] = i*i;
    x3[i] = i*i*i;
  }
  
}

parameters {
  real A[Nc];
  real B[Nc];
  real C[Nc];
  real D[Nc];
  real < lower =0 > sigma;
  real Amu0;
  real < lower =0 > Asigma0;
  real Bmu0;
  real < lower =0 > Bsigma0;
  real Cmu0;
  real < lower =0 > Csigma0;
  real Dmu0;
  real < lower =0 > Dsigma0;
}
 
 model {
    Amu0 ~ normal(0,0.1);
    Bmu0 ~ normal(0,1);
    Cmu0 ~ normal(0,10);
    Dmu0 ~ normal(0,100);
    Asigma0 ~ inv_chi_square(10);
    Bsigma0 ~ inv_chi_square(1);
    Csigma0 ~ inv_chi_square(0.1);
    Dsigma0 ~ inv_chi_square(0.01);
    sigma ~ inv_chi_square(0.001);
   
    A ~ normal(Amu0,Asigma0);
    B ~ normal(Bmu0,Bsigma0);
    C ~ normal(Cmu0,Csigma0);
    D ~ normal(Dmu0,Dsigma0);
   
    for ( j in 1: Nc ){
      y[j, ] ~ normal (A[j]*x3 + B[j]*x2 + C[j]*x1 + D[j] , sigma);
    }
 }
 
 generated quantities {
    matrix [Nc,Npred] ypred;
    vector [Nc*N] log_like;
    vector [Nc*N] y_rep;
    
    for ( j in 1: Nc ){
      for(i in (N+1):(N+Npred)){
        ypred[j,i - N] = normal_rng(A[j]*i*i*i + B[j]*i*i + C[j]*i + D[j] , sigma);
      }
    }
    
    for ( j in 1: Nc ){
      for ( i in 1: N){
        log_like[(j-1)*N + i] = normal_lpdf(y[j, i] | (A[j]*i*i*i + B[j]*i*i + C[j]*i + D[j]) , sigma);
        y_rep[(j-1)*N + i] = normal_rng(A[j]*i*i*i + B[j]*i*i + C[j]*i + D[j] , sigma);
      }
    }
}
"

sm_cubic <- rstan::stan_model(model_code = code_cubic)
continents_cubic_model <- rstan::sampling(sm_cubic, data = data_continents, control = list(max_treedepth = 15)) 
continents_cubic_model@stanmodel@dso <- new("cxxdso") 
saveRDS(continents_cubic_model, file = "continents_cubic_model.rds")
```




```{r}
code_powerlaw = "data {
 int < lower =0 > N; // number of data points
 int < lower =0 > Nc; //number of countries/continents
 matrix [Nc,N] y; // observation life expectancies, Nc countries
 int< lower =0 > Npred ; // predict this many years forward
}

transformed data{
  vector[N] x1; // just use years 1,2,...N instead giving x as argument
  for ( i in 1: N){
    x1[i] = i;
  }
  
}

parameters {
  real alpha[Nc];
  real beta[Nc];
  real<lower=0,upper= 1> lambda[Nc];
  
  real < lower =0 > sigma;
  real bmu0;
  real < lower =0 > bsigma0;
  real amu0;
  real < lower =0 > asigma0;
  real < lower =0 > beta1;
  real < lower =0 > beta2;
}

 
 model {
    bmu0 ~ normal(0,100); // yearly change/slope
    amu0 ~ normal(0,100); // we have observations at x = 1 so lets just use something close to that
    bsigma0 ~ inv_chi_square(0.01); // deviation around 10
    asigma0 ~ inv_chi_square(0.01); // deviation around 10
    sigma ~ inv_chi_square(0.01); // deviation around 10 years
    beta1 ~ exponential(0.1); // mean 10
    beta2 ~ exponential(0.1); // mean 10
    lambda ~ beta(beta1, beta2); 
    
   beta ~ normal(bmu0,bsigma0);
   alpha ~ normal(amu0,asigma0);
   
   for ( j in 1: Nc ){
     for ( i in 1: N ){
        y[j, i] ~ normal(alpha[j] - beta[j] * pow(lambda[j], x1[i]) , sigma);
     }
   }
 }
 
 generated quantities {
    matrix [Nc,Npred] ypred;
    vector [Nc*N] log_like;
    vector [Nc*N] y_rep;
    
    for ( j in 1: Nc ){
      for(i in (N+1):(N+Npred)){
        ypred[j,i - N] = normal_rng(alpha[j] - beta[j] * pow(lambda[j], i) , sigma);
      }
    }
    
    for ( j in 1: Nc ){
      for ( i in 1: N){
        log_like[(j-1)*N + i] = normal_lpdf(y[j, i] | (alpha[j] - beta[j] * pow(lambda[j], i)) , sigma);
        y_rep[(j-1)*N + i] = normal_rng(alpha[j] - beta[j] * pow(lambda[j], i), sigma);
      }
    }
}
"

sm_powerlaw <- rstan::stan_model(model_code = code_powerlaw)
continents_powerlaw <- rstan::sampling(sm_powerlaw, data = data_continents, control = list(max_treedepth = 15)) 
continents_powerlaw@stanmodel@dso <- new("cxxdso") 
saveRDS(continents_powerlaw, file = "continents_powerlaw.rds")
```


```{r}
code_powerlaw_wdip = "data {
 int < lower =0 > N; // number of data points
 int < lower =0 > Nc; //number of countries/continents
 matrix [Nc,N] y; // observation life expectancies, Nc countries
 int< lower =0 > Npred ; // predict this many years forward
}

transformed data{
  vector[N] x1; // just use years 1,2,...N instead giving x as argument
  for ( i in 1: N){
    x1[i] = i;
  }
  
}

parameters {
  real alpha[Nc];
  real beta[Nc];
  real<lower=0,upper= 1> lambda[Nc];
  
  real < lower =0 > sigma;
  real bmu0;
  real < lower =0 > bsigma0;
  real amu0;
  real < lower =0 > asigma0;
  real < lower =0 > beta1;
  real < lower =0 > beta2;
  
  
  real< lower =0 > Amp[Nc];
  real  mu_dip[Nc];
  real< lower =0 > sigma_dip[Nc];
}

 
 model {
    bmu0 ~ normal(40,10); // yearly change/slope
    amu0 ~ normal(90,15); // we have observations at x = 1 so lets just use something close to that
    bsigma0 ~ inv_chi_square(0.001); // deviation around 10 
    asigma0 ~ inv_chi_square(0.001); // deviation around 10
    sigma ~ inv_chi_square(0.1); // deviation around 3 years
    
    beta1 ~ exponential(0.025); // mean 40
    beta2 ~ exponential(0.1); // mean 10
    lambda ~ beta(beta1, beta2); 
    
    Amp ~ exponential(0.05);
    sigma_dip ~ inv_chi_square(0.01);
    mu_dip ~ normal(20, 100);
    
   beta ~ normal(bmu0,bsigma0);
   alpha ~ normal(amu0,asigma0);
   
   for ( j in 1: Nc ){
     for ( i in 1: N ){
        y[j, i] ~ normal(alpha[j] - beta[j] * pow(lambda[j], x1[i]) - Amp[j]*exp(normal_lpdf(x1[i] | mu_dip[j], sigma_dip[j])), sigma);
     }
   }
 }
 
 generated quantities {
    matrix [Nc,Npred] ypred;
    vector [Nc*N] log_like;
    vector [Nc*N] y_rep;
    
    for ( j in 1: Nc ){
      for(i in (N+1):(N+Npred)){
        ypred[j,i - N] = normal_rng(alpha[j] - beta[j] * pow(lambda[j], i)- Amp[j]*exp(normal_lpdf(i | mu_dip[j], sigma_dip[j])) , sigma);
      }
    }
    
    for ( j in 1: Nc ){
      for ( i in 1: N){
        log_like[(j-1)*N + i] = normal_lpdf(y[j, i] | (alpha[j] - beta[j] * pow(lambda[j], i)) - Amp[j]*exp(normal_lpdf(i | mu_dip[j], sigma_dip[j])) , sigma);
        y_rep[(j-1)*N + i] = normal_rng(alpha[j] - beta[j] * pow(lambda[j], i)- Amp[j]*exp(normal_lpdf(i | mu_dip[j], sigma_dip[j])), sigma);
      }
    }
}
"

sm_powerlaw_wdip <- rstan::stan_model(model_code = code_powerlaw_wdip)
continents_powerlaw_wdip <- rstan::sampling(sm_powerlaw_wdip, data = data_continents, iter = 6000, warmup = 5000 ,control = list(max_treedepth = 15,adapt_delta = 0.99) ) 
continents_powerlaw_wdip@stanmodel@dso <- new("cxxdso") 
saveRDS(continents_powerlaw_wdip, file = "continents_powerlaw_wdip.rds")
```

# MODEL COMPARISON AND LEAVE ONE OUT CROSS-VALIDATION (LOO)

https://mc-stan.org/loo/articles/loo2-with-rstan.html
http://avehtari.github.io/BDA_R_demos/demos_rstan/ppc/poisson-ppc.html

```{r}
library("loo")
options(mc.cores = 4)

#continents_linear_model <- readRDS("continents_linear_model_wpriors.rds")
#continents_powerlaw <- readRDS("continents_powerlaw.rds")
#continents_powerlaw_priors <- readRDS("continents_powerlaw_priors.rds")
#continents_cubic_model <- readRDS("continents_cubic_model.rds")

loo_cubic <- loo(continents_cubic_model,pars = "log_like")
loo_power <- loo(continents_powerlaw,pars = "log_like")
loo_power_priors <- loo(continents_powerlaw_priors,pars = "log_like")
loo_linear <- loo(continents_linear_model,pars = "log_like")

print(loo_cubic)
print(loo_power)
print(loo_power_priors)
print(loo_linear)

```
```{r}
loo_compare(loo_cubic,loo_linear,loo_power,loo_power_priors)
```
```{r}
monitor(continents_powerlaw_priors, pars = 'alpha')
monitor(continents_powerlaw, pars = 'alpha')
```

```{r}
par(mfrow=c(1,3))
plot(loo_power_priors, main = "Exponential model Pareto-k")
plot(loo_cubic, main = "Cubic model Pareto-k")
plot(loo_linear, main = "Linear model Pareto-k")
```


```{r}
monitor(continents_powerlaw_wdip)
```


```{r}
y_rep <- as.matrix(continents_linear_model, pars = "y_rep")

# number of rows = number of post-warmup posterior draws
# number of columns = length(y)


#How many draws to plot
Nplot <- 50
cont <- 1
ppc_dens_overlay(continents_num[cont,], y_rep[1:Nplot, 1+ (cont-1)*length(years):cont *length(years)])
```


```{r}
library(reshape2)

comp <- list(Old_priors = as.data.frame(continents_powerlaw)$`alpha[4]`, New_priors = as.data.frame(continents_powerlaw_priors)$`alpha[4]` )

comp_data <- melt(comp)
p_sens <- ggplot(comp_data,aes(x=value, fill=L1)) + geom_density(alpha=0.4)  +geom_vline(xintercept=quantile(comp$Old_priors,c(0.99)), colour = "red",size=0.5) +geom_vline(xintercept=quantile(comp$New_priors,c(0.99)), colour = "blue",size=0.5)

p_sens +  labs(x = "a_4 parameter for Europe", fill = "legend")

ggsave("sensitivity.png", plot = p_sens)

```

```{r}
code_powerlaw = "data {
 int < lower =0 > N; // number of data points
 int < lower =0 > Nc; //number of countries/continents
 matrix [Nc,N] y; // observation life expectancies, Nc countries
 int< lower =0 > Npred ; // predict this many years forward
}

transformed data{
  vector[N] x1; // just use years 1,2,...N instead giving x as argument
  for ( i in 1: N){
    x1[i] = i;
  }
  
}

parameters {
  real alpha[Nc];
  real beta[Nc];
  real<lower=0,upper= 1> lambda[Nc];
  
  real < lower =0 > sigma;
  real bmu0;
  real < lower =0 > bsigma0;
  real amu0;
  real < lower =0 > asigma0;
  real < lower =0 > beta1;
  real < lower =0 > beta2;
}

 
 model {
    bmu0 ~ normal(0,20); // yearly change/slope
    amu0 ~ normal(0,20); // we have observations at x = 1 so lets just use something close to that
    bsigma0 ~ inv_chi_square(1); // deviation around 10
    asigma0 ~ inv_chi_square(1); // deviation around 10
    sigma ~ inv_chi_square(1); // deviation around 10 years
    beta1 ~ exponential(1); // mean 10
    beta2 ~ exponential(1); // mean 10
    lambda ~ beta(beta1, beta2); 
    
   beta ~ normal(bmu0,bsigma0);
   alpha ~ normal(amu0,asigma0);
   
   for ( j in 1: Nc ){
     for ( i in 1: N ){
        y[j, i] ~ normal(alpha[j] - beta[j] * pow(lambda[j], x1[i]) , sigma);
     }
   }
 }
 
 generated quantities {
    matrix [Nc,Npred] ypred;
    vector [Nc*N] log_like;
    vector [Nc*N] y_rep;
    
    for ( j in 1: Nc ){
      for(i in (N+1):(N+Npred)){
        ypred[j,i - N] = normal_rng(alpha[j] - beta[j] * pow(lambda[j], i) , sigma);
      }
    }
    
    for ( j in 1: Nc ){
      for ( i in 1: N){
        log_like[(j-1)*N + i] = normal_lpdf(y[j, i] | (alpha[j] - beta[j] * pow(lambda[j], i)) , sigma);
        y_rep[(j-1)*N + i] = normal_rng(alpha[j] - beta[j] * pow(lambda[j], i), sigma);
      }
    }
}
"

sm_powerlaw <- rstan::stan_model(model_code = code_powerlaw)
continents_powerlaw <- rstan::sampling(sm_powerlaw, data = data_continents, control = list(max_treedepth = 15)) 
continents_powerlaw@stanmodel@dso <- new("cxxdso") 
saveRDS(continents_powerlaw, file = "continents_powerlaw.rds")
```
